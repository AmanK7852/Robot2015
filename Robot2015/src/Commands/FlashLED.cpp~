// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "../Robot.h"
#include "FlashLED.h"

const bool testing = true;

const double voltsPerInch = 0.012446;
const double minDistance = 11;
const double maxSweetSpotDistance = 12.5;
const double maxDistance = 18;

bool forceOn, forceOff;
int onInterval, offInterval;
double distance;

Notifier* nOn;
Notifier* nOff;

void turnLEDOn() {
	if (forceOff)
		Robot::lEDSubsystem->lED->Set(0);
	else
		Robot::lEDSubsystem->lED->Set(1);
	nOff->StartSingle(onInterval);
}

void turnLEDOff() {
	if (forceOn)
		Robot::lEDSubsystem->lED->Set(1);
	else
		Robot::lEDSubsystem->lED->Set(0);
	nOn->StartSingle(offInterval);
}

FlashLED::FlashLED() {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::lEDSubsystem);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// Called just before this Command runs the first time
void FlashLED::Initialize() {
	forceOn = false;
	forceOff = true;
	onInterval = 1;
	offInterval = 1;

	nOn = new Notifier((TimerEventHandler)turnLEDOn);
	nOff = new Notifier((TimerEventHandler)turnLEDOff);
	nOff->StartSingle(0.001);

}

// Called repeatedly when this Command is scheduled to run
void FlashLED::Execute() {
	distance = Robot::lEDSubsystem->lEDUltrasonic->GetAverageVoltage() / voltsPerInch;

	if (testing){
		//Just a simple on-off
		if (distance > minDistance && distance < maxDistance)
			Robot::lEDSubsystem->lED->Set(1);
		else
			Robot::lEDSubsystem->lED->Set(0);
	} else {
		//Flashing depending on distance
		if (distance < minDistance || distance > maxDistance) {
			forceOff = true;
			forceOn = false;
		} else {
			forceOff = false;
			if (distance > minDistance && distance < maxSweetSpotDistance)
				forceOn = true;
			else
				forceOn = false;
		}
	}
}

// Make this return true when this Command no longer needs to run execute()
bool FlashLED::IsFinished() {
	return (distance > maxDistance) || (distance < minDistance);
}

// Called once after isFinished returns true
void FlashLED::End() {
	Robot::lEDSubsystem->lED->Set(0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void FlashLED::Interrupted() {
	End();
}
